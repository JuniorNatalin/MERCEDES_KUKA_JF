&ACCESS RO19
&COMMENT BASIS package
DEF  BAS (COMMAND :IN,REAL_PAR :IN )
  DECL BAS_COMMAND COMMAND
  REAL REAL_PAR

  SWITCH  COMMAND
  CASE #INITMOV
    INITMOV ( )
  CASE #ACC_CP
    ACC_CP (REAL_PAR )
  CASE #ACC_GLUE
    ACC_GLUE (REAL_PAR )
  CASE #ACC_PTP
    ACC_PTP (REAL_PAR )
  CASE #VEL_CP
    VEL_CP (REAL_PAR )
  CASE #VEL_PTP
    VEL_PTP (REAL_PAR )
  CASE #TOOL
    TOOL (REAL_PAR )
  CASE #BASE
    BASE (REAL_PAR )
  CASE #EX_BASE
    EX_BASE (REAL_PAR )
  CASE #FRAMES
    FRAMES ( )
  CASE #CP_DAT
    CP_DAT ( )
  CASE #PTP_DAT
    PTP_DAT ( )
  CASE #OUT_SYNC
    OUT_SYNC ( )
  CASE #OUT_ASYNC
    OUT_ASYNC ( )
  CASE #GROUP
    GROUP (REAL_PAR )

  ENDSWITCH

END
DEF  INITMOV ( )
  INT I

  ; PTP-Parameters:
  ACC_PTP (100.0 ) ; ptp acceleration 100% = DEF_ACC_PTP
  VEL_PTP (100.0 ) ; ptp velocity 100% = DEF_VEL_PTP

  ; CP-Parameters:
  ACC_CP (100.0 ) ; path acceleration 100%  =  DEF_ACC_CP
  $ACC.ORI1=DEF_ACC_ORI1 ; swivel acceleration
  $ACC.ORI2=DEF_ACC_ORI2 ; rotation acceleration

  VEL_CP (DEF_VEL_CP ) ; path velocity 
  $VEL.ORI1=DEF_VEL_ORI1 ; swivel velocity
  $VEL.ORI2=DEF_VEL_ORI2 ; rotation velocity

  ; Parameters for Approximation:
  $APO.CPTP=DEF_APO_CPTP ; PTP-Approximation
  $APO.CDIS=DEF_APO_CDIS ; Distance-Approximation
  $APO.CVEL=DEF_APO_CVEL ; Speed-Approximation
  $APO.CORI=DEF_APO_CORI ; Orientation-Approximation

  $FILTER=$DEF_FLT_PTP ; filter
  $ADVANCE=DEF_ADVANCE ; advance
  $ORI_TYPE=#VAR ; variable orientation
  $CIRC_TYPE=DEF_CIRC_TYP ; CIRC-orientation defined in $config.dat
  TOOL_CORR=$NULLFRAME
  BASE_CORR=$NULLFRAME
  BASE_CORR_ON=FALSE

  IF $KINCLASS<>#NONE THEN
    BASE (0 ) ; Activating Base $WORLD
    $TOOL=TOOL_DATA[1]
    $ACT_TOOL=1
  ENDIF

  IF $TCP_IPO==TRUE THEN
    $IPO_MODE=#BASE
  ENDIF

  IF $ADAP_ACC<>#NONE THEN
    IF LOAD_A1_DATA.M<0 THEN
      $LOAD_A1.M=0
      $LOAD_A1.CM={X 0.0, Y 0.0, Z 0.0, A 0.0, B 0.0, C 0.0}
      $LOAD_A1.J={X 0.0, Y 0.0, Z 0.0}
    ELSE
      $LOAD_A1.M=LOAD_A1_DATA.M
      $LOAD_A1.CM=LOAD_A1_DATA.CM
      $LOAD_A1.J=LOAD_A1_DATA.J
    ENDIF
    IF LOAD_A2_DATA.M<0 THEN
      $LOAD_A2.M=0
      $LOAD_A2.CM={X 0.0, Y 0.0, Z 0.0, A 0.0, B 0.0, C 0.0}
      $LOAD_A2.J={X 0.0, Y 0.0, Z 0.0}
    ELSE
      $LOAD_A2.M=LOAD_A2_DATA.M
      $LOAD_A2.CM=LOAD_A2_DATA.CM
      $LOAD_A2.J=LOAD_A2_DATA.J
    ENDIF
    IF LOAD_A3_DATA.M<0 THEN
      $LOAD_A3.M=$DEF_LA3_M
      $LOAD_A3.CM=$DEF_LA3_CM
      $LOAD_A3.J=$DEF_LA3_J
    ELSE
      $LOAD_A3.M=LOAD_A3_DATA.M
      $LOAD_A3.CM=LOAD_A3_DATA.CM
      $LOAD_A3.J=LOAD_A3_DATA.J
      IF (($LOAD_A3.M<>0) AND ($LOAD_A3.J.X==0) AND ($LOAD_A3.J.Y==0) AND ($LOAD_A3.J.Z==0)) THEN
        $LOAD_A3.J=$DEF_LA3_J
      ENDIF
    ENDIF
  ENDIF

  ; standard group definition
  COMPL_GROUP=1
  FOR I=1 TO  $EX_AX_NUM
    COMPL_GROUP=COMPL_GROUP*2+1
  ENDFOR
  $ACT_GROUP=COMPL_GROUP

  ; torque monitoring
  IF $ADAP_ACC<>#NONE THEN
    FOR I=1 TO  6
      $TORQMON[I]=$TORQMON_DEF[I]
    ENDFOR
  ENDIF

  STOPM_FLAG=FALSE ;reflects state of interrupt 3

END

DEF  ACC_CP (ACC_FACTOR :IN )
  REAL ACC_FACTOR ; [%]

  IF ACC_FACTOR>100.0 THEN
    $ACC.CP=DEF_ACC_CP
    $ACC.ORI1=DEF_ACC_ORI1
    $ACC.ORI2=DEF_ACC_ORI2
  ELSE
    $ACC.CP=DEF_ACC_CP*ACC_FACTOR/100.0
    $ACC.ORI1=DEF_ACC_ORI1*ACC_FACTOR/100.0
    $ACC.ORI2=DEF_ACC_ORI2*ACC_FACTOR/100.0
  ENDIF
END

DEF  ACC_GLUE (ACC_FACTOR :IN )
  REAL ACC_FACTOR ; [%]

  IF ACC_FACTOR>100.0 THEN
    $ACC.CP=$ACC_MA.CP
    $ACC.ORI1=$ACC_MA.ORI1
    $ACC.ORI2=$ACC_MA.ORI2
  ELSE
    $ACC.CP=$ACC_MA.CP*ACC_FACTOR/100.0
    $ACC.ORI1=$ACC_MA.ORI1*ACC_FACTOR/100.0
    $ACC.ORI2=$ACC_MA.ORI2*ACC_FACTOR/100.0
  ENDIF
END

DEF  ACC_PTP (ACC_FACTOR :IN )
  REAL ACC_FACTOR ; [%]
  REAL ACC
  INT I

  CONTINUE
  IF $ADAP_ACC==#NONE THEN
    IF ACC_FACTOR>100.0 THEN
      ACC=DEF_ACC_PTP
    ELSE
      ACC=DEF_ACC_PTP*ACC_FACTOR/100.0
    ENDIF
  ELSE
    ACC=ACC_FACTOR
  ENDIF

  FOR I=1 TO  $NUM_AX
    $ACC_AXIS[I]=ACC
  ENDFOR

  FOR I=1 TO  $EX_AX_NUM
    $ACC_EXTAX[I]=ACC
  ENDFOR
END

DEF  VEL_CP (VEL_VALUE :IN )
  REAL VEL_VALUE ; [m/s]
  INT I

  IF VEL_VALUE>DEF_VEL_CP THEN
    $VEL.CP=DEF_VEL_CP
  ELSE
    $VEL.CP=VEL_VALUE*DEF_VEL_FACT
  ENDIF

  FOR I=1 TO  $EX_AX_NUM
    $VEL_EXTAX[I]=DEF_VEL_PTP
  ENDFOR
END

DEF  VEL_PTP (VEL_FACTOR :IN )
  REAL VEL_FACTOR ; [%]
  REAL VEL
  INT I

  IF VEL_FACTOR>100.0 THEN
    VEL=DEF_VEL_PTP
  ELSE
    VEL=DEF_VEL_PTP*VEL_FACTOR/100.0
  ENDIF

  FOR I=1 TO  $NUM_AX
    $VEL_AXIS[I]=VEL
  ENDFOR

  FOR I=1 TO  $EX_AX_NUM
    $VEL_EXTAX[I]=VEL
  ENDFOR
END

DEF  TOOL (TOOL_NO :IN )
  INT TOOL_NO

  CONTINUE
  IF (TOOL_NO<=0) THEN
    IF TOOL_CORR_ON THEN
      $TOOL=TOOL_CORR
    ELSE
      $TOOL=$NULLFRAME
    ENDIF
    IF $ADAP_ACC<>#NONE THEN
      $LOAD.M=$DEF_L_M
      $LOAD.CM=$DEF_L_CM
      $LOAD.J=$DEF_L_J
    ENDIF
  ELSE
    CONTINUE
    IF TOOL_CORR_ON THEN
      $TOOL=TOOL_DATA[TOOL_NO]:TOOL_CORR
    ELSE
      $TOOL=TOOL_DATA[TOOL_NO]
    ENDIF
    IF $ADAP_ACC<>#NONE THEN
      IF LOAD_DATA[TOOL_NO].M<0 THEN
        $LOAD.M=$DEF_L_M
        $LOAD.CM=$DEF_L_CM
        $LOAD.J=$DEF_L_J
      ELSE
        $LOAD.M=LOAD_DATA[TOOL_NO].M
        $LOAD.CM=LOAD_DATA[TOOL_NO].CM
        $LOAD.J=LOAD_DATA[TOOL_NO].J
        IF (($LOAD.M<>0) AND ($LOAD.J.X==0) AND ($LOAD.J.Y==0) AND ($LOAD.J.Z==0)) THEN
          $LOAD.J=$DEF_L_J
        ENDIF
      ENDIF
    ENDIF

  ENDIF

  CONTINUE
  $ACT_TOOL=TOOL_NO

END


DEF  BASE (BASE_NO :IN )
  INT BASE_NO

  IF (BASE_NO<=0) THEN
    IF BASE_CORR_ON THEN
      $BASE=BASE_CORR:$WORLD
    ELSE
      $BASE=$WORLD
    ENDIF
  ELSE
    IF BASE_CORR_ON THEN
      $BASE=BASE_CORR:BASE_DATA[BASE_NO]
    ELSE
      $BASE=BASE_DATA[BASE_NO]
    ENDIF

  ENDIF
  CONTINUE
  $ACT_BASE=BASE_NO ; Storing actual Base-Number in global variable
  CONTINUE
  $ACT_EX_AX=-1
END

DEF  EX_BASE (EX_AX_NO :IN )
  INT EX_AX_NO

  CONTINUE
  IF (EX_AX_NO==$ACT_EX_AX) AND  NOT BASE_CORR_ON THEN
    RETURN 
  ENDIF

  IF EX_AX_NO>0 THEN
    IF BASE_CORR_ON THEN
      $BASE=EK(EX_AX_DATA[EX_AX_NO].ROOT,EX_AX_DATA[EX_AX_NO].EX_KIN,BASE_CORR:EX_AX_DATA[EX_AX_NO].OFFSET)
    ELSE
      $BASE=EK(EX_AX_DATA[EX_AX_NO].ROOT,EX_AX_DATA[EX_AX_NO].EX_KIN,EX_AX_DATA[EX_AX_NO].OFFSET)
    ENDIF
  ENDIF
  CONTINUE
  $ACT_EX_AX=EX_AX_NO ;Storing number of activated external axis in global variable
  CONTINUE
  $ACT_BASE=-1
END

DEF  FRAMES ( )
  INT I
  SET_IPO_MODE (FDAT_ACT.IPO_FRAME )
  TOOL (FDAT_ACT.TOOL_NO )
  IF (FDAT_ACT.BASE_NO<17) THEN
    BASE (FDAT_ACT.BASE_NO )
  ELSE
    EX_BASE (FDAT_ACT.BASE_NO-16 )
  ENDIF
  IF STOPM_FLAG==TRUE THEN ;no correct finish of IR_STOPMESS
    STOPM_FLAG=FALSE ;reflects state of interrupt 3
    INTERRUPT ON 3
  ENDIF   
END

DEF  PTP_DAT ( )
  VEL_PTP (PDAT_ACT.VEL )
  ACC_PTP (PDAT_ACT.ACC )
  $APO.CPTP=PDAT_ACT.APO_DIST
  ARC_CTRL ( )
END

DEF  CP_DAT ( )
  VEL_CP (LDAT_ACT.VEL )
  ACC_CP (LDAT_ACT.ACC )
  $APO.CDIS=LDAT_ACT.APO_DIST
  ARC_CTRL ( )
END

DEF  OUT_ASYNC ( )
  SWITCH  ODAT_ACT.OUT_MODE

  CASE #CONT_
    IF ODAT_ACT.PULSE_TIME>0 THEN
      CONTINUE
      PULSE ($OUT[ODAT_ACT.OUT_NO],ODAT_ACT.STATE,ODAT_ACT.PULSE_TIME )
    ELSE
      CONTINUE
      $OUT[ODAT_ACT.OUT_NO]=ODAT_ACT.STATE
    ENDIF

  CASE #STOP_
    IF ODAT_ACT.PULSE_TIME>0 THEN
      PULSE ($OUT[ODAT_ACT.OUT_NO],ODAT_ACT.STATE,ODAT_ACT.PULSE_TIME )
    ELSE
      $OUT[ODAT_ACT.OUT_NO]=ODAT_ACT.STATE
    ENDIF
  ENDSWITCH
END

DEF  OUT_SYNC ( )
  SWITCH  ODAT_ACT.OUT_MODE

  CASE #TRIGGER_
    IF ODAT_ACT.PULSE_TIME>0 THEN
      CONTINUE
      PULSE ($OUT[ODAT_ACT.OUT_NO],ODAT_ACT.STATE,ODAT_ACT.PULSE_TIME )
    ELSE
      CONTINUE
      $OUT[ODAT_ACT.OUT_NO]=ODAT_ACT.STATE
    ENDIF
  ENDSWITCH

END

DEF  GROUP (GROUP_NO :IN )
  INT GROUP_NO
  $ACT_GROUP=DEF_GROUP[GROUP_NO]
END

DEF  SET_IPO_MODE (IPO_FRAME :IN )
  DECL IPO_MODE IPO_FRAME
  IF $IPO_MODE==IPO_FRAME THEN
    RETURN 
  ELSE
    $IPO_MODE=IPO_FRAME
  ENDIF
END
;------------------------
; WEAVING AND BLOCK SELECT
; TO A NON ARC_CMD
;------------------------
DEF  ARC_CTRL ( )

  IF ((A10_OPTION==#ACTIVE) OR (ARC20==TRUE)) THEN
    CONTINUE
    IF (($MOVE_BCO==TRUE) OR ($PRO_MODE==#BSTEP )) THEN
      IF A_FG_MECH1>0 THEN
        $TECH[A_FG_MECH1].MODE=#OFF
      ENDIF
      IF A_FG_MECH2>0 THEN
        $TECH[A_FG_MECH2].MODE=#OFF
      ENDIF
      TECH_MOTION=FALSE
      IF A50_OPTION==#ACTIVE THEN
        IF A_FG_SENSOR>0 THEN
          $TECH[A_FG_SENSOR].MODE=#OFF
        ENDIF
        TECH_MOTION=FALSE
      ENDIF
      IF A10_OPTION==#ACTIVE THEN
        IF SAVE_OVR>0 THEN
          $OV_PRO=SAVE_OVR
        ENDIF
        SAVE_OVR=(-1)
      ENDIF
    ENDIF
  ENDIF

END ;(ARC_CTRL)